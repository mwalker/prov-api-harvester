#!/usr/bin/env python3
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "csv-diff",
#     "git-filter-repo",
# ]
# ///

"""
Rewrite automated commit messages using the new improved format.

This script leverages test-commit-message.py logic and git filter-repo to selectively
rewrite only the automated commits (identified by UTC timestamp pattern).

Prerequisites:
- Working directory must be clean (git-filter-repo will be installed via uv)

Usage:
    uv run rewrite-automated-commits.py [--dry-run]

Arguments:
    --dry-run    Show what would be changed without actually doing it
"""

import argparse
import re
import subprocess
import sys
from datetime import datetime


def run_command(cmd, capture_output=True, check=True):
    """Run a command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=capture_output,
            text=True,
            check=check)
        return result.stdout.strip() if capture_output else None
    except subprocess.CalledProcessError as e:
        if check:
            print(f"Command failed: {' '.join(cmd)}")
            print(f"Error: {e.stderr if e.stderr else e}")
        return None


def is_automated_commit(commit_message):
    """Check if a commit message looks like it was generated by the automated workflow."""
    # Pattern: Day Month DD HH:MM:SS UTC YYYY
    utc_pattern = r'^[A-Za-z]{3}\s+[A-Za-z]{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}\s+UTC\s+\d{4}'
    return bool(re.match(utc_pattern, commit_message.strip()))


def extract_date_from_commit_message(commit_message):
    """Extract date from automated commit message."""
    # Pattern: Day Month DD HH:MM:SS UTC YYYY
    match = re.match(
        r'^[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d{1,2})\s+\d{2}:\d{2}:\d{2}\s+UTC\s+(\d{4})',
        commit_message.strip())
    if not match:
        return None

    month_name, day, year = match.groups()

    # Convert month name to number
    month_map = {
        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
    }

    month = month_map.get(month_name)
    if not month:
        return None

    # Format as YYYY-MM-DD
    return f"{year}-{month}-{day.zfill(2)}"


def pre_generate_all_commit_messages(automated_commits):
    """Pre-generate improved commit messages for specified automated commits."""
    print("Pre-generating improved commit messages...", file=sys.stderr)

    if not automated_commits:
        return {}

    commit_messages = {}
    total = len(automated_commits)

    for i, (commit_hash, original_message,
            date) in enumerate(automated_commits, 1):
        print(
            f"Generating message for commit {commit_hash[:8]} ({i}/{total})...", file=sys.stderr)

        try:
            # Use our existing test script to generate the improved message
            result = subprocess.run([
                "uv", "run", "scripts/test-commit-message.py", commit_hash
            ], capture_output=True, text=True, check=True)

            # Get the commit message directly
            new_message = result.stdout.strip()

            if new_message:
                # Use original message as key (since commit hashes will change
                # during rewrite)
                commit_messages[original_message] = new_message
                print(
                    f"✓ Generated message for {commit_hash[:8]}", file=sys.stderr)
            else:
                print(
                    f"✗ Empty message for {commit_hash[:8]}", file=sys.stderr)

        except subprocess.CalledProcessError as e:
            print(
                f"✗ Error generating message for {commit_hash[:8]}: {e}", file=sys.stderr)
            if e.stderr:
                print(f"  STDERR: {e.stderr}", file=sys.stderr)

    print(
        f"Pre-generated {len(commit_messages)} commit messages", file=sys.stderr)
    return commit_messages


def list_automated_commits():
    """List all automated commits that would be affected."""
    # Get all commits with their messages
    result = run_command([
        "git", "log", "--pretty=format:%H|%s", "--all"
    ])

    if not result:
        return []

    automated_commits = []
    for line in result.split('\n'):
        if '|' not in line:
            continue

        commit_hash, message = line.split('|', 1)
        if is_automated_commit(message):
            date = extract_date_from_commit_message(message)
            automated_commits.append((commit_hash, message, date))

    return automated_commits


def create_commit_message_callback(commit_messages):
    """Create a callback function for git filter-repo to rewrite commit messages."""

    def commit_message_callback(commit, metadata):
        original_message = commit.message.decode('utf-8')

        # Only process automated commits
        if not is_automated_commit(original_message):
            return  # Leave unchanged

        # Look up pre-generated message using original message as key
        # Use only the subject line (first line) to match our pre-generation
        # key
        original_subject = original_message.split('\n')[0]
        commit_hash = commit.original_id.hex()
        print(f"Processing commit {commit_hash[:8]}...", file=sys.stderr)

        if original_subject in commit_messages:
            new_message = commit_messages[original_subject]
            commit.message = new_message.encode('utf-8')
            print(f"✓ Rewrote commit {commit_hash[:8]}", file=sys.stderr)
        else:
            # Leave unchanged if we don't have a pre-generated message
            print(
                f"- Skipped commit {commit_hash[:8]} (no pre-generated message)", file=sys.stderr)

    return commit_message_callback


def main():
    parser = argparse.ArgumentParser(
        description='Rewrite automated commit messages using improved format.'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be changed without actually doing it'
    )
    parser.add_argument(
        '--max-commits',
        type=int,
        help='Maximum number of commits to process (useful for testing)'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable verbose debug output'
    )

    args = parser.parse_args()

    # git-filter-repo will be automatically available via uv dependencies

    # Check if working directory is clean
    status = run_command(["git", "status", "--porcelain"])
    if status:
        print("Error: Working directory is not clean")
        print("Please commit or stash your changes first")
        sys.exit(1)

    # List automated commits
    automated_commits = list_automated_commits()

    if not automated_commits:
        print("No automated commits found")
        return

    # Limit commits if requested
    if args.max_commits and args.max_commits < len(automated_commits):
        automated_commits = automated_commits[:args.max_commits]
        print(
            f"Limited to first {
                args.max_commits} automated commits (of {
                len(
                    list_automated_commits())} total)")

    print(f"Found {len(automated_commits)} automated commits:")
    for commit_hash, message, date in automated_commits[:10]:  # Show first 10
        print(f"  {commit_hash[:8]} ({date}): {message[:60]}...")

    if len(automated_commits) > 10:
        print(f"  ... and {len(automated_commits) - 10} more")

    if args.dry_run:
        print(
            f"\nDry run - testing commit message generation for {len(automated_commits)} commits")

        # Pre-generate messages during dry run to test the process
        commit_messages = {}
        for i, (commit_hash, original_message,
                date) in enumerate(automated_commits, 1):
            print(
                f"Testing message generation for commit {commit_hash[:8]} ({i}/{len(automated_commits)})...")

            try:
                result = subprocess.run([
                    "uv", "run", "scripts/test-commit-message.py", commit_hash
                ], capture_output=True, text=True, check=True)

                new_message = result.stdout.strip()

                if new_message:
                    commit_messages[original_message] = new_message
                    print(
                        f"✓ Generated message for {commit_hash[:8]} ({len(new_message)} chars)")
                    if args.verbose:
                        print("=" * 80)
                        print(f"{new_message}")
                        print("=" * 80)
                else:
                    print(f"✗ Empty message for {commit_hash[:8]}")

            except subprocess.CalledProcessError as e:
                print(f"✗ Error generating message for {commit_hash[:8]}: {e}")

        print(
            f"\nDry run complete - successfully generated {
                len(commit_messages)} of {
                len(automated_commits)} commit messages")
        print("Run without --dry-run to actually perform the rewrite")
        return

    print(
        f"\nThis will rewrite {
            len(automated_commits)} commits and change all commit hashes.")
    print("This is a destructive operation that will require force pushing.")
    print("Make sure you have a backup of your repository!")

    confirm = input("\nAre you sure you want to continue? (yes/no): ")
    if confirm.lower() != 'yes':
        print("Aborted")
        return

    # Pre-generate all commit messages before starting the rewrite
    commit_messages = pre_generate_all_commit_messages(automated_commits)

    if not commit_messages:
        print("Error: No commit messages were generated")
        return

    print(
        f"\nSuccessfully pre-generated {len(commit_messages)} commit messages")
    print("Starting commit rewrite...")

    # Run git filter-repo with our callback
    try:
        import git_filter_repo as fr

        # Set up filter-repo arguments
        filter_args = fr.FilteringOptions.parse_args([
            '--force',  # Required for filter-repo
        ])

        # Create the callback with pre-generated messages
        callback = create_commit_message_callback(commit_messages)

        # Run the filter
        filter_obj = fr.RepoFilter(filter_args, commit_callback=callback)
        filter_obj.run()

        print("\n✓ Commit message rewrite complete!")
        print("All commit hashes have changed.")
        print("You'll need to force push: git push origin --force --all")

    except ImportError:
        print("Error: Could not import git_filter_repo")
        print("This should not happen with uv dependencies")
        sys.exit(1)
    except Exception as e:
        print(f"Error during rewrite: {e}")
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except BrokenPipeError:
        sys.exit(0)
    except KeyboardInterrupt:
        print("\nAborted by user")
        sys.exit(1)
